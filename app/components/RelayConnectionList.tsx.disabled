'use client';

import type { RelayConnectionListItem_edge$key } from '@/__generated__/RelayConnectionListItem_edge.graphql';
import type { RelayConnectionList_node$key } from '@/__generated__/RelayConnectionList_node.graphql';
import { useConnection, useNode, usePagination, useSolver } from '@/app/client/backend';
import type { ConnectionPage, Log, SolverEdge, SolverNode, Transaction } from '@/lib-solver';
import type { EdgeType } from '@/lib-solver';
import { Collapse, List, ListItem, ListItemAvatar, ListItemButton } from '@mui/material';
import { memo, useCallback, useEffect, useTransition } from 'react';
import { graphql, useFragment, usePaginationFragment } from 'react-relay';
import { TransitionGroup } from 'react-transition-group';
import { FixedSizeList } from 'react-window';
import InfiniteLoader from 'react-window-infinite-loader';

import InfiniteList from './InfiniteList';
import { FallbackBoundary, NodeAvatar, SuspenseFallback } from './ui';

const connectionListQueryFragment = graphql`
  fragment RelayConnectionList_node on Node
  @argumentDefinitions(
    type: { type: "String!" }
    first: { type: "Int", defaultValue: 10 }
    after: { type: "String" }
  )
  @refetchable(queryName: "RelayConnectionListPaginationQuery") {
    connection(type: $type, first: $first, after: $after)
      @connection(key: "RelayConnectionList_node_connection") {
      edges {
        headId
        ...RelayConnectionListItem_edge
      }
    }
  }
`;

export default function RelayConnectionList<TEdge extends SolverEdge>({
  tail: tailFragment,
  edgeType,
  baseHref,
  renderItem,
  paginate,
}: {
  tail: RelayConnectionList_node$key;
  edgeType: EdgeType<TEdge>;
  baseHref: string;
  renderItem: (edge: TEdge) => React.ReactNode;
  paginate?: boolean;
}) {
  const {
    data: tail,
    loadNext,
    hasNext,
    hasPrevious,
    loadPrevious,
  } = usePaginationFragment(connectionListQueryFragment, tailFragment);

  // const onLoadNext = useCallback(() => {
  //   setSize((size) => size + 1);
  // }, [setSize]);

  // const itemCount = edges.length + 1;

  return (
    <>
      {/* <InfiniteLoader
        isItemLoaded={(index) => index < edges.length}
        itemCount={itemCount}
        loadMoreItems={onLoadNext}
      >
        {({ onItemsRendered, ref }) => (
          <List ref={ref}>
            <FixedSizeList
              itemCount={itemCount}
              onItemsRendered={onItemsRendered}
              ref={ref}
              height={400}
              width={300}
              itemSize={55}
              itemData={edges}
            >
              {({ index, style }) => {
                const edge = edges[index];
                if (!edge) {
                  return (
                    <ListItem dense disablePadding style={style}>
                      <ListItemButton>
                        <ListItemAvatar>
                          <NodeAvatar node={node} />
                        </ListItemAvatar>
                      </ListItemButton>
                    </ListItem>
                  );
                }
                // console.log(index);
                return (
                  <ListItem dense disablePadding style={style}>
                    <Collapse key={edge.headId}>
                    <FallbackBoundary
                      suspenseFallback={
                        <ListItemButton>
                          <ListItemAvatar>
                            <NodeAvatar node={node} />
                          </ListItemAvatar>
                        </ListItemButton>
                      }
                    >
                      <NodeRelayConnectionListItem edgeType={edgeType} tail={node} edge={edge}>
                        {renderItem(edge as any)}
                      </NodeRelayConnectionListItem>
                    </FallbackBoundary>
                    </Collapse>
                  </ListItem>
                );
              }}
            </FixedSizeList>
          </List>
        )}
      </InfiniteLoader> */}
      <InfiniteList
      // loadPrevious={hasPrevious && onLoadPrevious}
      // loadNext={paginate && loadNext}
      >
        <List>
          <TransitionGroup>
            {tail.connection.edges.map((edge) => (
              <Collapse key={edge.headId}>
                <ListItem dense disablePadding>
                  <FallbackBoundary
                    suspenseFallback={
                      <ListItemButton>
                        <ListItemAvatar>
                          <NodeAvatar nodeId={edge.headId} />
                        </ListItemAvatar>
                      </ListItemButton>
                    }
                  >
                    <RelayConnectionListItem edge={edge} edgeType={edgeType} baseHref={baseHref}>
                      {renderItem(edge as any)}
                    </RelayConnectionListItem>
                  </FallbackBoundary>
                </ListItem>
              </Collapse>
            ))}
          </TransitionGroup>
        </List>
      </InfiniteList>
    </>
  );
}

const connectionListItemQueryFragment = graphql`
  fragment RelayConnectionListItem_edge on Edge {
    headId
    tail {
      meta {
        slug
      }
    }
    head {
      meta {
        slug
      }
    }
  }
`;

const RelayConnectionListItem = memo(function RelayConnectionListItem({
  edge: edgeFragment,
  edgeType,
  baseHref,
  children,
}: {
  edge: RelayConnectionListItem_edge$key;
  edgeType: EdgeType<any>;
  baseHref: string;
  children: React.ReactNode;
}) {
  const edge = useFragment(connectionListItemQueryFragment, edgeFragment);
  // console.log('tail', tail);
  // console.log('node', node);

  const prefix = `${baseHref}${edge.tail.meta.slug}`;
  const suffix = `${edgeType.connectionName}/${edge.head.meta.slug}`;
  let href;
  switch (edgeType.name) {
    case 'ChainHasTransaction': {
      href = `${prefix}/blocks/${(edge.head as Transaction).data.blockNumber}/${suffix}`;
      break;
    }
    case 'BlockHasLog': {
      href = `${prefix}/transactions/${(edge.head as Log).data.transactionIndex}/${suffix}`;
      break;
    }
    default: {
      href = `${prefix}/${suffix}`;
      break;
    }
  }

  return (
    <ListItemButton href={href}>
      <ListItemAvatar>
        <NodeAvatar nodeId={edge.headId} />
      </ListItemAvatar>
      {children}
    </ListItemButton>
  );
});
